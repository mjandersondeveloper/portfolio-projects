Homework 1 - Bumpy Subsequence
------------------------------

- Sequence is bumpy when the signs of the difference b/w two consecutive terms in the sequence alternate b/w + and - values
- Difference of zero can never be part of a bumpy sequence
- Follows:
	- a_1 < a_2 > a_3 < a_4 > ... a_i OR
	- a_1 > a_2 < a_3 > a_4 < ... a_i
- Find the length of the longest bumpy sequence in A

1.) Define the entries of your table in words. E.g. T(i) or T(i, j) is...

- Let T(i) = be the maxmium length of the longest bumpy sequence from terms a_1....a_i.
- Let S(i) = be the sign of the last difference of the longest bumpy sequence from terms a_1....a_i

2.) State a recurrence for the entries of your table in terms of smaller subproblems.  Don't forget your base case(s).

- B.C.: T(1) = 1, S(1) = 0
- Recurrence: 
	- S(i) = a[i] - a[i-1] : if (a[i] - a[i-1] > 0 and S[i-1] <= 0) or (a[i] - a[i-1] < 0 and S[i-1] >= 0)
		   = S[i-1] : otherwise, 2 <= i <= n
	- T(i) = 1 + T[i-1] : if (a[i] - a[i-1] > 0 and S[i-1] <= 0) or (a[i] - a[i-1] < 0 and S[i-1] >= 0)
	       = T[i-1]: otherwise }, 2 <= i <= n

3.) Write pseudocode for your algorithm to solve this problem.
T[1] = 1
S[1] = 0
for i = 2 to n:
	x = a[i] - a[i-1]
	if (x > 0 and S[i-1] <= 0) or (x < 0 and S[i-1] >= 0):
		T[i] = 1 + T[i-1]
		S[i] = x
	else:
		T[i] = T[i-1]
		S[i] = S[i-1]
return T[n]

4.) State and analyze the running time of your algorithm

- Running a for loop across n-terms takes O(n) time.
- Overall runtime is O(n).

----------------------------------------------------------------------

Model Solution:

1.) Define the entries of your table in words. E.g. T(i) or T(i, j) is...

- Let T(i, 0) = be the length of the longest bumpy sequence from terms 1....i where a[i] > a[i-1].
- Let S(i, 1) = be the length of the longest bumpy sequence from terms 1....i where a[i] < a[i-1].

2.) State a recurrence for the entries of your table in terms of smaller subproblems.  Don't forget your base case(s).

- B.C.: T(1, 0) = 1, T(1, 1) = 1
- Recurrence: 
	- T(i, 0) = T(i-1, 1) + 1 : if a[i] > a[i-1]
			  = T(i-1, 0)     : otherwise, where 2 <= i <= n
	- T(i, 1) = T(i-1, 0) + 1 : if a[i] < a[i-1]
			  = T(i-1, 1)     : otherwise, where 2 <= i <= n

3.) Write pseudocode for your algorithm to solve this problem.
T(1, 0) = 1
T(1, 1) = 1
for i = 2 to n:
	T(i, 0) = T(i-1, 0)
	T(i, 1) = T(i-1, 1)
	if (a[i] > a[i-1]:
		T(i, 0) = T(i-1, 1) + 1
	if (a[i] < a[i-1]:
		T(i, 1) = T(i-1, 0) + 1
return max{T(n,.)}

4.) State and analyze the running time of your algorithm

- Running a for loop across n-terms takes O(n) time.
- Find the maximum value at T(n) takes O(n) time.
- Overall runtime is O(n).

