La Habana Hotel Stops

1.) Define the entries of your table in words. E.g. T(i) or T(i, j) is...

- Let T(i) = be the minimum most paid to travel from my hometown to hotel i and stay at hotel i

2.) State a recurrence for the entries of your table in terms of smaller subproblems.  Don't forget your base case(s).

Base Case: T[1] = p[1]
Recurrence: T[i] = p[i] : if d[i] <= 50
                 = min{T[j]} + p[i] : if d[i] > 50 and d[j] <= d[i] - 50, where 2 <= i <= n and 1 <= j <= i-1

3.) Write pseudocode for your algorithm to solve this problem.
T[1] = p[1]
for i = 2 to n:
	if d[i] <= 50:
		T[i] = p[i]
	else:
		T[i] = infinity
	for j = 1 to i-1:
		if d[i] > 50 and d[j] >= d[i] - 50:
			T[i] = min{T[i], T[j]} + p[i] 
return T[n]

4.) State and analyze the running time of your algorithm
- Running a nested for loop across n-hotels takes O(n^2).
- Overall runtime is O(n^2).

-------------------------------------------------------------------

Find Existing Number

Algorithm:
- We will use a modified binary search algorithm
- During the recursive search:
	- Check if A[mid] = 2(mid) + 5
		- If valid, return "yes"
	- Check if A[mid] > 2(mid) + 5, 
		- If valid, recursively search the left side of A
		- If not, recursively search the right side of A
		- This continues until we get to a single element, our base case
- Once the base case is achieved, if it equals 2(i) + 5, return "yes", if not, return "no"

Correctness:
- Since A is an increasingly sorted array (with odd numbers), we are able to use a modified binary search algorithm to recursively search the left and right side of A.
- If A[mid] > 2(mid) + 5, we know every value to the right of the array is greater than the dynamic target, so we search the left side of A.
- If A[mid] < 2(mid) + 5, we know every value to the left of the array is less than the dynamic target, so we search the right side of A.
- If A[mid] = 2(mid) + 5 is achieved by the time the base case is reached, we return "yes" accordingly. If not, we return "no".

Runtime:
- The known runtime for binary search is O(log n).
- Modifying the checks within the binary search can be done in O(1) time.
- The overall runtime is O(log n).